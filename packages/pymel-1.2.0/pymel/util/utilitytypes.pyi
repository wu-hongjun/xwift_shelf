import types
from collections import defaultdict as defaultdict
from future.utils import with_metaclass as with_metaclass
from typing import Any, Iterable, Optional, Type, TypeVar

T = TypeVar('T')

class Singleton(type):
    def __new__(mcl: Any, classname: Any, bases: Any, classdict: Any): ...

class metaStatic(Singleton):
    def __new__(mcl: Any, classname: Any, bases: Any, classdict: Any): ...

class defaultlist(list):
    default_factory: Any = ...
    def __init__(self, default_factory: Any, *args: Any, **kwargs: Any) -> None: ...
    def __setitem__(self, index: Any, item: Any) -> None: ...
    def __getitem__(self, index: Any): ...

class ModuleInterceptor:
    module: Any = ...
    callback: Any = ...
    def __init__(self, moduleName: Any, callback: Any) -> None: ...
    def __getattr__(self, attr: Any): ...

def readonly(f: Any): ...

class metaReadOnlyAttr(type):
    def __setattr__(cls, name: Any, value: Any) -> None: ...
    def __new__(mcl: Any, classname: Any, bases: Any, classdict: Any): ...

NOT_PROXY_WRAPPED: Any

def proxyClass(cls, classname: str, dataAttrName: str=..., dataFuncName: str=..., remove: Iterable[str]=..., makeDefaultInit: bool=..., sourceIsImmutable: bool=..., module: Any=...) -> Type[T]: ...

ProxyUnicode: Any

class universalmethod:
    f: Any = ...
    __doc__: Any = ...
    def __init__(self, f: Any) -> None: ...
    def __get__(self, instance: Any, cls: Optional[Any] = ...): ...

class LazyLoadModule(types.ModuleType):
    class LazyLoader:
        creator: Any = ...
        args: Any = ...
        kwargs: Any = ...
        name: Any = ...
        def __init__(self, name: Any, creator: Any, *creatorArgs: Any, **creatorKwargs: Any) -> None: ...
        newobj: Any = ...
        def __get__(self, obj: Any, objtype: Any): ...
    def __new__(cls, name: Any, contents: Any, autoSubClass: bool = ...): ...
    def __init__(self, name: Any, contents: Any, autoSubClass: bool = ...) -> None: ...
    def __dir__(self): ...
    def __setitem__(self, attr: Any, args: Any) -> None: ...
    def __getitem__(self, attr: Any): ...

class LazyDocStringError(Exception): ...

class LazyDocString:
    documentedObj: Any = ...
    docGetter: Any = ...
    args: Any = ...
    kwargs: Any = ...
    def __init__(self, argList: Any) -> None: ...

def makeMethod(name: Any): ...
def addLazyDocString(obj: Any, creator: Any, *creatorArgs: Any, **creatorKwargs: Any) -> None: ...

class TwoWayDict(dict):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __setitem__(self, k: Any, v: Any) -> None: ...
    def has_value(self, v: Any): ...
    def __delitem__(self, k: Any) -> None: ...
    def clear(self) -> None: ...
    def copy(self): ...
    def pop(self, k: Any): ...
    def popitem(self, **kws: Any) -> None: ...
    def setdefault(self, **kws: Any) -> None: ...
    def update(self, *args: Any, **kwargs: Any) -> None: ...
    def get_key(self, v: Any): ...

class EquivalencePairs(TwoWayDict):
    def __setitem__(self, k: Any, v: Any) -> None: ...
    def __delitem__(self, key: Any) -> None: ...
    def __getitem__(self, key: Any): ...
    def __contains__(self, key: Any): ...
    def get(self, key: Any, d: Optional[Any] = ...): ...

def alias(origAttrName: Any): ...

class propertycache:
    func: Any = ...
    name: Any = ...
    def __init__(self, func: Any) -> None: ...
    def __get__(self, ownerInstance: Any, ownerCls: Optional[Any] = ...): ...
