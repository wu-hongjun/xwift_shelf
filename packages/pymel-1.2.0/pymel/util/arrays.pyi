from typing import *
from . import mathutils as mathutils
from .arguments import clsname as clsname, isNumeric as isNumeric
from .mathutils import blend as blend, clamp as clamp, conjugate as conjugate, imag as imag, real as real, round as round
from .utilitytypes import metaReadOnlyAttr as metaReadOnlyAttr, readonly as readonly
from math import exp as exp, pi as pi
from typing import Any, Optional

def coerce(v1: Any, v2: Any): ...

eps: Any

def patchMath(): ...
def sum(a: Any, start: int = ..., axis: Optional[Any] = ...): ...
def prod(a: Any, start: int = ..., axis: Optional[Any] = ...): ...
def any(a: Any, axis: Optional[Any] = ...): ...
def all(a: Any, axis: Optional[Any] = ...): ...
def min(*args: Any, **kwargs: Any): ...
def max(*args: Any, **kwargs: Any): ...
def sqlength(a: Any, axis: Optional[Any] = ...): ...
def length(a: Any, axis: Optional[Any] = ...): ...
def normal(a: Any, axis: Optional[Any] = ...): ...
def dist(a: Any, b: Any, axis: Optional[Any] = ...): ...

class ArrayIter:
    base: Any = ...
    ndim: Any = ...
    size: Any = ...
    coords: Any = ...
    axis: Any = ...
    shape: Any = ...
    itemshape: Any = ...
    itemdim: Any = ...
    itemsize: Any = ...
    subsizes: Any = ...
    def __init__(self, data: Any, *args: Any) -> None: ...
    def __length_hint__(self): ...
    def __len__(self): ...
    def __iter__(self) -> Any: ...
    def __next__(self): ...
    def toArrayCoords(self, index: Any, default: Optional[Any] = ...): ...
    def __getitem__(self, index: Any): ...
    def __delitem__(self, index: Any) -> None: ...
    def __setitem__(self, index: Any, value: Any) -> None: ...

class Array:
    __readonly__: Any = ...
    apicls: Any = ...
    shape: Any = ...
    ndim: Any = ...
    size: Any = ...
    data: Any = ...
    def assign(self, value: Any): ...
    def get(self): ...
    def __new__(cls, *args: Any, **kwargs: Any): ...
    def __init__(self, *args: Any, **kwargs: Any): ...
    def filled(self, value: Optional[Any] = ...): ...
    def fill(self, value: Optional[Any] = ...) -> None: ...
    def appended(self, other: Any, axis: int = ...): ...
    def append(self, other: Any, axis: int = ...) -> None: ...
    def stacked(self, other: Any, axis: int = ...): ...
    def stack(self, other: Any, axis: int = ...) -> None: ...
    def hstacked(self, other: Any): ...
    def hstack(self, other: Any) -> None: ...
    def vstacked(self, other: Any): ...
    def vstack(self, other: Any) -> None: ...
    extended: Any = ...
    extend: Any = ...
    def reshaped(self, shape: Optional[Any] = ...): ...
    def reshape(self, shape: Optional[Any] = ...) -> None: ...
    def resized(self, shape: Optional[Any] = ..., value: Optional[Any] = ...): ...
    def resize(self, shape: Optional[Any] = ..., value: Optional[Any] = ...) -> None: ...
    def fitted(self, other: Any): ...
    def fit(self, other: Any) -> None: ...
    def trimmed(self, shape: Optional[Any] = ..., value: Optional[Any] = ...): ...
    def trim(self, shape: Optional[Any] = ..., value: Optional[Any] = ...) -> None: ...
    def __reduce__(self): ...
    def __getnewargs__(self): ...
    def copy(self): ...
    def deepcopy(self): ...
    def formated(self): ...
    def __len__(self): ...
    def __getitem__(self, index: Any): ...
    def __getslice__(self, start: Any, end: Any): ...
    def __setitem__(self, index: Any, value: Any) -> None: ...
    def __setslice__(self, start: Any, end: Any, value: Any) -> None: ...
    def __delitem__(self, index: Any) -> None: ...
    def __delslice__(self, start: Any) -> None: ...
    def deleted(self, *args: Any): ...
    def strip(self, *args: Any) -> None: ...
    def stripped(self, *args: Any): ...
    def __iter__(self, *args: Any, **kwargs: Any) -> Any: ...
    def axisiter(self, *args: Any): ...
    def subiter(self, dim: Optional[Any] = ...): ...
    @property
    def flat(self): ...
    def tolist(self): ...
    def totuple(self): ...
    __hash__: Any = ...
    def ravel(self): ...
    def __contains__(self, value: Any): ...
    def count(self, value: Any): ...
    def index(self, value: Any): ...
    def __coerce__(self, other: Any): ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...
    __neq__: Any = ...
    def __abs__(self): ...
    def __invert__(self): ...
    def __round__(self, ndigits: int = ...): ...
    def __pos__(self): ...
    def __neg__(self): ...
    def __add__(self, other: Any): ...
    def __radd__(self, other: Any): ...
    def __iadd__(self, other: Any): ...
    def __sub__(self, other: Any): ...
    def __rsub__(self, other: Any): ...
    def __isub__(self, other: Any): ...
    def __mul__(self, other: Any): ...
    def __rmul__(self, other: Any): ...
    def __imul__(self, other: Any): ...
    def __pow__(self, other: Any, modulo: Optional[Any] = ...): ...
    def __rpow__(self, other: Any): ...
    def __ipow__(self, other: Any, modulo: Optional[Any] = ...): ...
    def __div__(self, other: Any): ...
    def __rdiv__(self, other: Any): ...
    def __idiv__(self, other: Any): ...
    def __truediv__(self, other: Any): ...
    def __rtruediv__(self, other: Any): ...
    def __itruediv__(self, other: Any): ...
    def __floordiv__(self, other: Any): ...
    def __rfloordiv__(self, other: Any): ...
    def __ifloordiv__(self, other: Any): ...
    def __mod__(self, other: Any): ...
    def __rmod__(self, other: Any): ...
    def __imod__(self, other: Any): ...
    def sum(self, *args: Any, **kwargs: Any): ...
    def prod(self, *args: Any, **kwargs: Any): ...
    def any(self, *args: Any, **kwargs: Any): ...
    def all(self, *args: Any, **kwargs: Any): ...
    def min(self, *args: Any, **kwargs: Any): ...
    def max(self, *args: Any, **kwargs: Any): ...
    def sqlength(self, *args: Any): ...
    def length(self, *args: Any): ...
    def normal(self, *args: Any): ...
    def normalize(self, *args: Any) -> None: ...
    def dist(self, other: Any, *args: Any): ...
    def distanceTo(self, other: Any): ...
    def isEquivalent(self, other: Any, tol: Any = ...): ...
    def transpose(self, *args: Any): ...
    T: Any = ...
    def conjugate(self): ...
    def real(self): ...
    def imag(self): ...
    def blend(self, other: Any, weight: float = ...): ...
    def clamp(self, low: int = ..., high: int = ...): ...

def det(value: Any): ...
def inv(value: Any): ...

class MatrixN(Array):
    ndim: int = ...
    shape: Any = ...
    size: Any = ...
    def is_square(self): ...
    @classmethod
    def identity(cls, n: Any): ...
    @classmethod
    def basis(cls, u: Any, v: Any, normalize: bool = ...): ...
    nrow: Any = ...
    ncol: Any = ...
    @property
    def row(self): ...
    @property
    def col(self): ...
    def __mul__(self, other: Any): ...
    def __rmul__(self, other: Any): ...
    def __imul__(self, other: Any): ...
    def diagonal(self, offset: int = ..., wrap: bool = ...): ...
    def trace(self, offset: int = ..., wrap: bool = ...): ...
    def minor(self, i: Any, j: Any): ...
    def cofactor(self, i: Any, j: Any): ...
    def adjugate(self): ...
    def gauss(self): ...
    def reduced(self): ...
    def det(self): ...
    def isSingular(self, tol: Any = ...): ...
    def inverse(self): ...
    inv: Any = ...
    I: Any = ...
    def linverse(self): ...
    def rinverse(self): ...

def cross(u: Any, v: Any): ...
def dot(u: Any, v: Any): ...
def outer(u: Any, v: Any): ...
def angle(a: Any, b: Any, c: Optional[Any] = ...): ...
def axis(a: Any, b: Any, c: Optional[Any] = ..., normalize: bool = ...): ...
def cotan(a: Any, b: Any, c: Optional[Any] = ...): ...

class VectorN(Array):
    ndim: int = ...
    shape: Any = ...
    size: Any = ...
    def __mul__(self, other: Any): ...
    def __rmul__(self, other: Any): ...
    def __imul__(self, other: Any): ...
    def __xor__(self, other: Any): ...
    def __ixor__(self, other: Any): ...
    def cross(self, other: Any): ...
    def dot(self, other: Any): ...
    def outer(self, other: Any): ...
    def transformAsNormal(self, other: Any): ...
    def sqlength(self) -> float: ...
    def length(self) -> float: ...
    def normal(self): ...
    unit: Any = ...
    def isParallel(self, other: Any, tol: Any = ...): ...
    def angle(self, other: Any, third: Optional[Any] = ...): ...
    def axis(self, other: Any, third: Optional[Any] = ..., normalize: bool = ...): ...
    def cotan(self, other: Any, third: Optional[Any] = ...): ...
    def projectionOnto(self, other: Any): ...
