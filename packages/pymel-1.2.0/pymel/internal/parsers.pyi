import abc
from . import plogging as plogging
from abc import abstractmethod
from html.parser import HTMLParser
from pymel.mayautils import getMayaLocation as getMayaLocation
from typing import Any, Optional

FLAGMODES: Any

class MethodParseError(ValueError): ...
class UnmatchedNameError(ValueError): ...

def mayaIsRunning() -> bool: ...
def mayaDocsLocation(version: Optional[Any] = ...): ...
def decodeEntity(tagname: Any): ...
def iterXmlTextAndElem(element: Any) -> None: ...
def getFirstText(element: Any, ignore: Any = ...): ...
def xmlText(element: Any, strip: bool = ..., allowNone: bool = ...): ...
def standardizeWhitespace(text: Any): ...

class MLStripper(HTMLParser):
    fed: Any = ...
    def __init__(self) -> None: ...
    def handle_data(self, d: Any) -> None: ...
    def handle_startendtag(self, tag: Any, attrs: Any) -> None: ...
    def get_data(self): ...

def strip_tags(html: Any): ...
def standardizeUnicodeChars(input: Any): ...
def standardizeDoc(input: Any): ...

class CommandDocParser(HTMLParser):
    command: Any = ...
    flags: Any = ...
    currFlag: str = ...
    iData: int = ...
    pcount: int = ...
    active: bool = ...
    description: str = ...
    example: str = ...
    emptyModeFlags: Any = ...
    internal: bool = ...
    def __init__(self, command: Any) -> None: ...
    def startFlag(self, data: Any) -> None: ...
    def addFlagData(self, data: Any) -> None: ...
    def endFlag(self) -> None: ...
    def handle_starttag(self, tag: Any, attrs: Any) -> None: ...
    def handle_endtag(self, tag: Any) -> None: ...
    def handle_data(self, data: Any) -> None: ...

class NodeHierarchyDocParser(HTMLParser):
    def parse(self): ...
    version: Any = ...
    currentTag: Any = ...
    depth: int = ...
    lastDepth: int = ...
    tree: Any = ...
    currentLeaves: Any = ...
    def __init__(self, version: Optional[Any] = ...) -> None: ...
    def handle_starttag(self, tag: Any, attrs: Any) -> None: ...
    def handle_data(self, data: Any) -> None: ...

def printTree(tree: Any, depth: int = ...) -> None: ...

class CommandModuleDocParser(HTMLParser):
    def parse(self): ...
    cmdList: Any = ...
    category: Any = ...
    version: Any = ...
    docloc: Any = ...
    def __init__(self, category: Any, version: Optional[Any] = ...) -> None: ...
    def handle_starttag(self, tag: Any, attrs: Any) -> None: ...

class NO_DEFAULT: ...

class ParamInfo:
    defName: Any = ...
    declName: Any = ...
    type: Any = ...
    typeQualifiers: Any = ...
    default: Any = ...
    direction: Any = ...
    def __init__(self, defName: Optional[Any] = ..., declName: Optional[Any] = ..., type: Optional[Any] = ..., typeQualifiers: Any = ..., default: Any = ..., direction: str = ..., doc: str = ...) -> None: ...
    @property
    def name(self): ...
    @name.setter
    def name(self, val: Any) -> None: ...
    @property
    def doc(self): ...
    @doc.setter
    def doc(self, rawVal: Any) -> None: ...
    def qualifiedTypeName(self): ...

class ApiDocParser(metaclass=abc.ABCMeta):
    NO_PYTHON_MSG: Any = ...
    DEPRECATED_MSG: Any = ...
    PYMEL_ENUM_DEFAULTS: Any = ...
    MISSING_TYPES: Any = ...
    OTHER_TYPES: Any = ...
    NOT_TYPES: Any = ...
    BASIC_NUMERIC_TYPES: Any = ...
    NON_MFN_FULL_PARSE_CLASSES: Any = ...
    SKIP_PARSING_METHODS: Any = ...
    CPP_OPERATOR_TO_PY: Any = ...
    PY_OPERATOR_DEFAULT_NAMES: Any = ...
    DEFNAMES: Any = ...
    def __new__(cls, apiModule: Any, version: Optional[Any] = ..., *args: Any, **kwargs: Any): ...
    version: Any = ...
    apiModule: Any = ...
    verbose: Any = ...
    docloc: Any = ...
    enumClass: Any = ...
    strict: Any = ...
    enums: Any = ...
    pymelEnums: Any = ...
    methods: Any = ...
    currentMethodName: Any = ...
    badEnums: Any = ...
    def __init__(self, apiModule: Any, version: Optional[Any] = ..., verbose: bool = ..., enumClass: Any = ..., docLocation: Optional[Any] = ..., strict: bool = ...) -> None: ...
    @classmethod
    def shouldSkip(cls, apiClsName: Any): ...
    @classmethod
    def shouldParseEnumOnly(cls, apiClsName: Any): ...
    @classmethod
    def splitArrayType(cls, origType: Union[str, ApiEnum]) -> Tuple[str, Optional[int]]: ...
    @classmethod
    def isGettableArg(cls, param: ParamInfo) -> bool: ...
    @property
    def currentRawMethod(self): ...
    @currentRawMethod.setter
    def currentRawMethod(self, val: Any) -> None: ...
    @staticmethod
    def methodcached(getter: Any): ...
    def fullMethodName(self, paramInfos: Optional[Any] = ...): ...
    def formatMsg(self, *args: Any): ...
    def xprint(self, *args: Any) -> None: ...
    def getPymelMethodNames(self): ...
    def getClassFilename(self): ...
    def isBadEnum(self, type: Any): ...
    def handleEnums(self, type: Any): ...
    def handleEnumDefaults(self, default: Any, type: Any): ...
    def getOperatorName(self, methodName: Any): ...
    def isSetMethod(self): ...
    def isGetMethod(self): ...
    def parseValue(self, rawValue: Any, valueType: Any): ...
    def parseType(self, tokens: Any): ...
    def parseEnum(self, enumData: Any) -> None: ...
    def parseMethod(self, rawMethod: Any): ...
    constants: Any = ...
    apiClassName: Any = ...
    apiClass: Any = ...
    docfile: Any = ...
    def setClass(self, apiClassName: Any) -> None: ...
    def parse(self, apiClassName: Any): ...
    @abstractmethod
    def parseArgTypes(self) -> Any: ...
    @abstractmethod
    def hasNoPython(self) -> Any: ...
    @abstractmethod
    def isStaticMethod(self) -> Any: ...
    @abstractmethod
    def isDeprecated(self) -> Any: ...
    @abstractmethod
    def getMethodDoc(self) -> Any: ...
    @abstractmethod
    def parseMethodArgs(self, paramInfos: Any, returnInfo: Any) -> Any: ...
    @abstractmethod
    def getMethodNameAndOutput(self) -> Any: ...
    @abstractmethod
    def getClassPath(self) -> Any: ...
    @abstractmethod
    def parseBody(self) -> Any: ...

class XmlApiDocParser(ApiDocParser):
    def fullMethodName(self, paramInfos: Optional[Any] = ...): ...
    tree: Any = ...
    root: Any = ...
    cdef: Any = ...
    numAnonymousEnums: int = ...
    def setClass(self, apiClassName: Any) -> None: ...
    def parseArgTypes(self): ...
    def isMayaEnumFunc(self, element: Any): ...
    currentMethodName: Any = ...
    def hasNoPython(self): ...
    def isDeprecated(self): ...
    def isStaticMethod(self): ...
    @classmethod
    def iterBackslashTags(cls, text: Any, subTags: Any = ...) -> None: ...
    @classmethod
    def parseBackslashTags(cls, text: Any, allTags: bool = ...): ...
    def findDetailedDescription(self): ...
    def getMethodDoc(self): ...
    def parseMethodArgs(self, oldParamInfos: Any, returnInfo: Any): ...
    def getMethodNameAndOutput(self): ...
    baseFilename: Any = ...
    def getClassPath(self): ...
    def parseBody(self) -> None: ...

class HtmlApiDocParser(ApiDocParser):
    def parseArgTypes(self): ...
    currentMethodName: Any = ...
    def hasNoPython(self): ...
    def isStaticMethod(self): ...
    def findAddendum(self): ...
    def isDeprecated(self): ...
    def getMethodDoc(self): ...
    def parseMethodArgs(self, returnType: Any, names: Any, types: Any, typeQualifiers: Any): ...
    TYPEDEF_RE: Any = ...
    def getMethodNameAndOutput(self): ...
    DOXYGEN_VER_RE: Any = ...
    def getDoxygenVersion(self, soup: Any): ...
    def getClassPath(self): ...
    soup: Any = ...
    doxygenVersion: Any = ...
    def setClass(self, apiClassName: Any) -> None: ...
    def parseBody(self) -> None: ...
