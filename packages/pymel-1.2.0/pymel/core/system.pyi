from typing import *
import pymel.util as _util
import abc
import pymel.core.general as general
import pymel.core.nodetypes as nt
from builtins import str
from pymel.util.decoration import decorator as decorator
from pymel.util.scanf import fscanf as fscanf
from typing import Any, Optional

basePathName: Any
buf: Any
moduleName: Any
className: Any
pathModule: Any
pathClass: Any
pathClass = _util.path
displayError: Any
displayWarning: Any
displayInfo: Any

def feof(fileid: Any): ...
def sceneName(): ...
def untitledFileName(): ...

class UndoChunk:
    name: Any = ...
    def __init__(self, name: Optional[Any] = ...) -> None: ...
    def __enter__(self): ...
    def __exit__(*args: Any, **kwargs: Any) -> None: ...

class Namespace(str):
    @classmethod
    def getCurrent(cls) -> Namespace: ...
    @classmethod
    def create(cls, name: Any) -> Namespace: ...
    def __new__(cls, namespace: Any, create: bool = ...): ...
    def __add__(self, other: Any): ...
    def __cmp__(self, other: Any): ...
    __eq__: Any = ...
    __ne__: Any = ...
    __le__: Any = ...
    __lt__: Any = ...
    __ge__: Any = ...
    __gt__: Any = ...
    def __hash__(self) -> Any: ...
    def splitAll(self) -> List[str]: ...
    def shortName(self) -> str: ...
    def getParent(self) -> Optional[Namespace]: ...
    def ls(self, pattern: Any=..., **kwargs: Any) -> List[general.PyNode]: ...
    def getNode(self, nodeName: Any, verify: Any=...) -> general.PyNode: ...
    def listNamespaces(self, recursive: bool=..., internal: bool=...) -> List[Namespace]: ...
    def listNodes(self, recursive: bool=..., internal: bool=...) -> List[general.PyNode]: ...
    def setCurrent(self) -> None: ...
    def clean(self, haltOnError: bool=..., reparentOtherChildren: bool=...) -> None: ...
    def move(self, other: Any, force: bool = ...) -> None: ...
    def remove(self, haltOnError: bool=..., reparentOtherChildren: bool=...) -> None: ...

def listNamespaces_old(): ...
def listNamespaces(root: Any=..., recursive: Any=..., internal: Any=...) -> List[Namespace]: ...
def namespaceInfo(*args: Any, **kwargs: Any): ...

class Translator:
    @staticmethod
    def listRegistered(): ...
    @staticmethod
    def fromExtension(ext: str, mode: str=..., caseSensitive: bool=...) -> Optional[Translator]: ...
    def __init__(self, name: Any) -> None: ...
    def extension(self): ...
    ext: Any = ...
    name: Any = ...
    def filter(self): ...
    def optionsScript(self): ...
    def hasReadSupport(self): ...
    def hasWriteSupport(self): ...
    def getDefaultOptions(self): ...
    def setDefaultOptions(self, options: Any) -> None: ...
    def getFileCompression(self): ...
    def setFileCompression(self, compression: Any) -> None: ...

class WorkspaceEntryDict:
    entryType: Any = ...
    def __init__(self, entryType: Any) -> None: ...
    def __getitem__(self, item: Any): ...
    def __setitem__(self, item: Any, value: Any): ...
    def __contains__(self, key: Any): ...
    def items(self): ...
    def keys(self): ...
    def values(self): ...
    def get(self, item: Any, default: Optional[Any] = ...): ...
    def __iter__(self) -> Any: ...
    has_key: Any = ...

class Workspace:
    objectTypes: Any = ...
    fileRules: Any = ...
    renderTypes: Any = ...
    variables: Any = ...
    @classmethod
    def open(self, workspace: Any): ...
    @classmethod
    def save(self): ...
    @classmethod
    def update(self): ...
    @classmethod
    def new(self, workspace: Any): ...
    @classmethod
    def getName(self): ...
    @classmethod
    def getPath(self): ...
    @classmethod
    def chdir(self, newdir: Any): ...
    @classmethod
    def getcwd(self): ...
    @classmethod
    def mkdir(self, newdir: Any): ...
    @property
    def path(self): ...
    @property
    def name(self): ...
    def __call__(self, *args: Any, **kwargs: Any): ...
    def expandName(self, path: Any): ...

workspace: Any

class SingletonABCMeta(_util.Singleton, abc.ABCMeta): ...

class FileInfo:
    def __getitem__(self, item: str) -> str: ...
    def __setitem__(self, item: Any, value: Any) -> None: ...
    def __delitem__(self, item: Any) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any): ...
    def items(self): ...
    def keys(self): ...
    def __iter__(self) -> Any: ...
    def __len__(self): ...
    has_key: Any = ...

fileInfo: Any

class Path(pathClass):
    getTypeName: Any = ...
    setSubType: Any = ...


@overload
def iterReferences(parentReference: Union[str, Path, FileReference]=..., recursive: bool=..., namespaces: Literal[False]=..., refNodes: Literal[False]=..., references: Literal[True]=..., recurseType: str=..., loaded: Optional[bool]=..., unloaded: Optional[bool]=...) -> Iterator[FileReference]: ...
@overload
def iterReferences(parentReference: Union[str, Path, FileReference]=..., recursive: bool=..., namespaces: Literal[True]=..., refNodes: Literal[False]=..., references: Literal[False]=..., recurseType: str=..., loaded: Optional[bool]=..., unloaded: Optional[bool]=...) -> Iterator[str]: ...
@overload
def iterReferences(parentReference: Union[str, Path, FileReference]=..., recursive: bool=..., namespaces: Literal[False]=..., refNodes: Literal[True]=..., references: Literal[False]=..., recurseType: str=..., loaded: Optional[bool]=..., unloaded: Optional[bool]=...) -> Iterator[nt.Reference]: ...
def listReferences(parentReference: Union[str, Path, FileReference]=..., recursive: bool=..., namespaces: bool=..., refNodes: bool=..., references: bool=..., loaded: Optional[bool]=..., unloaded: Optional[bool]=...) -> List[Union[FileReference, Tuple[str, FileReference], Tuple[str, FileReference, nt.Reference]]]: ...
def getReferences(parentReference: Any=..., recursive: Any=...) -> Dict[str, FileReference]: ...

class FileReference:
    def __init__(self, pathOrRefNode: Optional[Any] = ..., namespace: Optional[Any] = ..., refnode: Optional[Any] = ...) -> None: ...
    def __melobject__(self): ...
    def __gt__(self, other: Any) -> Any: ...
    def __ge__(self, other: Any) -> Any: ...
    def __lt__(self, other: Any) -> Any: ...
    def __le__(self, other: Any) -> Any: ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...
    def __hash__(self) -> Any: ...
    def subReferences(self) -> Dict[str, FileReference]: ...
    def namespaceExists(self): ...
    namespace: Any = ...
    @property
    def fullNamespace(self) -> str: ...
    @property
    def refNode(self): ...
    @property
    def path(self) -> Path: ...
    def withCopyNumber(self) -> str: ...
    def unresolvedPath(self) -> Path: ...
    def parent(self) -> Optional[FileReference]: ...
    def importContents(self, removeNamespace: bool = ...): ...
    def remove(self, **kwargs: Any): ...
    def unload(self): ...
    def load(self, newFile: Optional[Any] = ..., **kwargs: Any): ...
    def replaceWith(self, newFile: Any, **kwargs: Any): ...
    def clean(self, **kwargs: Any): ...
    def lock(self): ...
    def unlock(self): ...
    def isDeferred(self): ...
    def isLoaded(self): ...
    def nodes(self, recursive: bool = ...): ...
    def copyNumberList(self): ...
    def selectAll(self): ...
    def isUsingNamespaces(self): ...
    def exportAnim(self, exportPath: Any, **kwargs: Any): ...
    def exportSelectedAnim(self, exportPath: Any, **kwargs: Any): ...
    def getReferenceEdits(self, **kwargs: Any): ...
    def removeReferenceEdits(self, editCommand: str=..., force: bool=..., **kwargs: Any) -> None: ...

def referenceQuery(*args: Any, **kwargs: Any): ...

class ReferenceEdit(str):
    type: Any = ...
    fileReference: Any = ...
    successful: Any = ...
    def __new__(cls, editStr: Any, fileReference: Optional[Any] = ..., successful: Optional[Any] = ...): ...
    namespace: Any = ...
    fullNamespace: Any = ...
    def remove(self, force: bool = ...) -> None: ...
    editData: Any = ...
    rawEditData: Any = ...

def createReference(filepath: Any, **kwargs: Any): ...
def loadReference(filepath: Any, **kwargs: Any): ...
def exportAll(exportPath: Any, **kwargs: Any): ...
def exportAsReference(exportPath: Any, **kwargs: Any): ...
def exportSelected(exportPath: Any, **kwargs: Any): ...
def exportAnim(exportPath: Any, **kwargs: Any): ...
def exportSelectedAnim(exportPath: Any, **kwargs: Any): ...
def exportAnimFromReference(exportPath: Any, **kwargs: Any): ...
def exportSelectedAnimFromReference(exportPath: Any, **kwargs: Any): ...
def importFile(filepath: Any, **kwargs: Any): ...
def newFile(**kwargs: Any): ...
def openFile(filepath: Any, **kwargs: Any): ...
def renameFile(newname: Any, *args: Any, **kwargs: Any): ...
def saveFile(**kwargs: Any): ...
def saveAs(newname: Any, **kwargs: Any) -> Path: ...
def isModified(): ...

aaf2fcp: Any
allNodeTypes: Any
assignInputDevice: Any
attachDeviceAttr: Any
attrCompatibility: Any
audioTrack: Any
autoSave: Any
cacheFile: Any
cacheFileCombine: Any
cacheFileMerge: Any
cacheFileTrack: Any
clearCache: Any
cmdFileOutput: Any
convertUnit: Any
crashInfo: Any
dagObjectCompare: Any
date: Any
dbcount: Any
dbfootprint: Any
dbmessage: Any
dbpeek: Any
dbtrace: Any
detachDeviceAttr: Any
deviceEditor: Any

def devicePanel(*args: Any, **kwargs: Any): ...

dgInfo: Any
dgValidateCurve: Any
dgdirty: Any
dgeval: Any
dgfilter: Any
dgmodified: Any
dgtimer: Any
dirmap: Any
diskCache: Any
displayString: Any
dynamicLoad: Any
error: Any

def exportEdits(*args: Any, **kwargs: Any): ...

fcheck: Any

def fileBrowserDialog(*args: Any, **kwargs: Any): ...

fileDialog: Any

def fileDialog2(*args: Any, **kwargs: Any): ...

filePathEditor: Any
findType: Any
flushUndo: Any
getFileList: Any
getInputDeviceRange: Any
getModifiers: Any
getModulePath: Any
hardware: Any
hitTest: Any
imfPlugins: Any
internalVar: Any
launch: Any
launchImageEditor: Any
listDeviceAttachments: Any
listInputDeviceAxes: Any
listInputDeviceButtons: Any
listInputDevices: Any
loadModule: Any

def loadPlugin(*args: Any, **kwargs: Any): ...

melInfo: Any
memory: Any
moduleInfo: Any
mouse: Any
namespace: Any
ogs: Any
openCLInfo: Any
openGLExtension: Any
openMayaPref: Any
pluginDisplayFilter: Any

def pluginInfo(*args: Any, **kwargs: Any): ...
def preloadRefEd(*args: Any, **kwargs: Any): ...

profiler: Any
profilerTool: Any
recordAttr: Any
redo: Any

def reference(*args: Any, **kwargs: Any): ...
def referenceEdit(*args: Any, **kwargs: Any): ...

rehash: Any
reloadImage: Any
requires: Any

def saveImage(*args: Any, **kwargs: Any): ...
def sceneEditor(*args: Any, **kwargs: Any): ...

sceneUIReplacement: Any
scriptNode: Any
selLoadSettings: Any
setAttrMapping: Any
setInputDeviceMapping: Any
shotTrack: Any
showHelp: Any
sysFile: Any
timer: Any
timerX: Any
translator: Any
unassignInputDevice: Any
undo: Any
undoInfo: Any
unknownNode: Any
unknownPlugin: Any

def unloadPlugin(*args: Any, **kwargs: Any): ...

warning: Any
whatsNewHighlight: Any
xpmPicker: Any
