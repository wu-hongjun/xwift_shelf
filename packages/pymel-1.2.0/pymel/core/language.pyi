from typing import *
import abc
import pymel.util as util
from collections import MutableMapping
from future.utils import PY2 as PY2
from pymel.core import system as system
from typing import Any, Optional

MELTYPES: Any

def isValidMelType(typStr: Any) -> bool: ...
def pythonToMel(arg: str) -> str: ...
def pythonToMelCmd(command: Any, *args: Any, **kwargs: Any): ...
def getMelType(pyObj: Any, exactOnly: bool=..., allowBool: bool=..., allowMatrix: bool=...) -> str: ...

class MelGlobals(MutableMapping, _Parent, metaclass=abc.ABCMeta):
    melTypeToPythonType: Any = ...
    class MelGlobalArray(util.defaultlist):
        def __init__(self, type: Any, variable: Any, *args: Any, **kwargs: Any) -> None: ...
        def __setitem__(self, index: Any, value: Any) -> None: ...
        setItem: Any = ...
        def append(self, val: Any) -> None: ...
        def extend(self, val: Any) -> None: ...
    typeMap: Dict[str, str] = ...
    VALID_TYPES: Any = ...
    def __iter__(self) -> Any: ...
    def __len__(self): ...
    def __getitem__(self, variable: str) -> str: ...
    def __setitem__(self, variable: str, value: Any) -> Any: ...
    @classmethod
    def getType(cls, variable: str) -> str: ...
    @classmethod
    def initVar(cls, type: str, variable: str) -> str: ...
    def get_dict(self, variable: Any, default: Optional[Any] = ...): ...
    @classmethod
    def get(cls, variable: str, type: Optional[str]=...) -> Any: ...
    @classmethod
    def set(cls, variable: str, value: Any, type: Optional[str]=...) -> None: ...
    @classmethod
    def keys(cls) -> List[str]: ...

melGlobals: Any

def getMelGlobal(type: Any, variable: Any): ...
def setMelGlobal(type: Any, variable: Any, value: Any): ...

class Catch:
    result: Any = ...
    success: Any = ...
    def __call__(self, func: Any, *args: Any, **kwargs: Any): ...
    def reset(self) -> None: ...

catch: Any

class OptionVarList(tuple):
    def __new__(cls, val: Any, key: Any): ...
    key: Any = ...
    def __init__(self, val: Any, key: Any) -> None: ...
    def __setitem__(self, key: Any, val: Any) -> None: ...
    def appendVar(self, val: Any): ...
    append: Any = ...

class OptionVarDict(MutableMapping):
    def __call__(self, *args: Any, **kwargs: Any): ...
    def __contains__(self, key: Any): ...
    def has_key(self, key: Any): ...
    def __getitem__(self, key: Any): ...
    def __setitem__(self, key: Any, val: Any): ...
    def keys(self): ...
    def pop(self, key: Any): ...
    def __delitem__(self, key: Any) -> None: ...
    def iterkeys(self) -> None: ...
    __iter__: Any = ...
    def __len__(self): ...

optionVar: Any

class Env:
    optionVars: Any = ...
    envVars: Any = ...
    def setConstructionHistory(self, state: Any) -> None: ...
    def getConstructionHistory(self): ...
    def sceneName(self): ...
    def setUpAxis(self, axis: Any, rotateView: bool = ...) -> None: ...
    def getUpAxis(self): ...
    def user(self): ...
    def host(self): ...
    def getTime(self): ...
    def setTime(self, val: Any) -> None: ...
    time: Any = ...
    def getMinTime(self): ...
    def setMinTime(self, val: Any) -> None: ...
    minTime: Any = ...
    def getMaxTime(self): ...
    def setMaxTime(self, val: Any) -> None: ...
    maxTime: Any = ...
    def getAnimStartTime(self): ...
    def setAnimStartTime(self, val: Any) -> None: ...
    animStartTime: Any = ...
    def getAnimEndTime(self): ...
    def setAnimEndTime(self, val: Any) -> None: ...
    animEndTime: Any = ...
    def getPlaybackTimes(self): ...
    def setPlaybackTimes(self, playbackTimes: Any) -> None: ...
    playbackTimes: Any = ...

env: Any

class MelError(RuntimeError): ...
class MelConversionError(MelError, TypeError): ...
class MelUnknownProcedureError(MelError, NameError): ...
class MelArgumentError(MelError, TypeError): ...
class MelSyntaxError(MelError, SyntaxError): ...

class MelCallable:
    full_name: Any = ...
    def __init__(self, head: Any, name: Any) -> None: ...
    def __getattr__(self, command: Any): ...
    def __call__(self, *args: Any, **kwargs: Any): ...

class Mel:
    proc: Any = ...
    def __getattr__(self, command: Any): ...
    @classmethod
    def mprint(cls, *args: Any) -> None: ...
    @classmethod
    def source(cls, script: str, language: str=...) -> None: ...
    @classmethod
    def eval(cls, cmd: Any): ...
    @staticmethod
    def error(msg: Any, showLineNumber: bool = ...) -> None: ...
    @staticmethod
    def warning(msg: Any, showLineNumber: bool = ...) -> None: ...
    @staticmethod
    def trace(msg: Any, showLineNumber: bool = ...) -> None: ...
    @staticmethod
    def tokenize(*args: Any) -> None: ...
    globals: Any = ...

mel: Any

def conditionExists(conditionName: str) -> None: ...
def callbacks(*args: Any, **kwargs: Any): ...

evalEcho: Any
evalNoSelectNotify: Any
getLastError: Any
getProcArguments: Any
matrixUtil: Any
melOptions: Any
python: Any
resourceManager: Any

def scriptJob(*args: Any, **kwargs: Any): ...

sortCaseInsensitive: Any
stackTrace: Any
waitCursor: Any
