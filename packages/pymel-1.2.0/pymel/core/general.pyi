from typing import *
import pymel.util as _util
import pymel.core.datatypes as datatypes
import pymel.core.nodetypes as nodetypes
import pymel.core.nodetypes as nt
import pymel.core.other as other
from builtins import str
from pymel.util.enum import Enum as Enum
from pymel.util.py2to3 import RePattern as RePattern
from typing import Any, Optional

TYPE_CHECKING: bool
CHECK_ATTR_BEFORE_LOCK: Any

def select(*args: Any, **kwargs: Any) -> None: ...
def move(*args: Any, **kwargs: Any): ...
def scale(obj: Any, *args: Any, **kwargs: Any): ...
def rotate(obj: Any, *args: Any, **kwargs: Any): ...
def connectAttr(source: Any, destination: Any, **kwargs: Any) -> None: ...
def disconnectAttr(source: Any, destination: Optional[Any] = ..., inputs: Optional[Any] = ..., outputs: Optional[Any] = ..., **kwargs: Any) -> None: ...
def getAttr(attr: Any, default: Optional[Any] = ..., **kwargs: Any): ...

class AmbiguityWarning(Warning): ...

def setAttr(attr: Any, *args: Any, **kwargs: Any) -> None: ...
def addAttr(*args: Any, **kwargs: Any): ...
def hasAttr(pyObj: PyNode, attr: Union[str, Attribute, AttributeSpec], checkShape: bool=...) -> bool: ...
def setEnums(attr: Any, enums: Any) -> None: ...
def getEnums(attr: Union[str, Attribute]) -> _util.enum.EnumDict: ...
def listConnections(arg: Any, connections: Literal[True]=..., plugs: Literal[True]=..., **kwargs: Any) -> List[Tuple[Attribute, Attribute]]: ...
def listHistory(*args: Any, **kwargs: Any) -> List[nodetypes.DependNode]: ...
def listFuture(*args: Any, **kwargs: Any) -> List[nodetypes.DependNode]: ...
def listRelatives(*args: Any, **kwargs: Any) -> List[nodetypes.DependNode]: ...
def ls(*args: Any, **kwargs: Any) -> List[PyNode]: ...
def listTransforms(*args: Any, **kwargs: Any) -> List[nodetypes.Transform]: ...
def listSets(*args: Any, **kwargs: Any) -> List[PyNode]: ...
def nodeType(node: Any, **kwargs: Any) -> str: ...
def group(*args: Any, **kwargs: Any): ...
def parent(*args: Any, **kwargs: Any) -> List[nodetypes.DagNode]: ...

class NodeTracker:
    def __init__(self) -> None: ...
    def startTrack(self) -> None: ...
    def endTrack(self) -> None: ...
    def getNodes(self, returnType: str=...) -> None: ...
    def isTracking(self): ...
    def reset(self) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exctype: Any, excval: Any, exctb: Any) -> None: ...

def duplicate(*args: Any, **kwargs: Any) -> List[nodetypes.DependNode]: ...
def rename(obj: Any, newname: Any, **kwargs: Any): ...
def createNode(*args: Any, **kwargs: Any): ...
def sets(*args: Any, **kwargs: Any): ...
def delete(*args: Any, **kwargs: Any) -> None: ...
def getClassification(*args: Any, **kwargs: Any): ...
def uniqueObjExists(name: Any): ...
def selected(**kwargs: Any): ...
def spaceLocator(*args: Any, **kwargs: Any): ...
def instancer(*args: Any, **kwargs: Any): ...

class MayaObjectError(TypeError):
    node: Any = ...
    def __init__(self, node: Optional[Any] = ...) -> None: ...

class MayaNodeError(MayaObjectError): ...
class MayaAttributeError(MayaObjectError, AttributeError): ...

class MayaAttributeEnumError(MayaAttributeError):
    enum: Any = ...
    def __init__(self, node: Optional[Any] = ..., enum: Optional[Any] = ...) -> None: ...

class MayaComponentError(MayaAttributeError): ...
class MayaInstanceError(MayaNodeError): ...

class DeletedMayaNodeError(MayaNodeError):
    def __init__(self, node: Optional[Any] = ...) -> None: ...
    @classmethod
    def handle(cls, pynode: Any) -> None: ...

class MayaParticleAttributeError(MayaComponentError): ...

class PyNode(_util.ProxyUnicode):
    __apiobjects__: Any = ...
    def __new__(cls, *args: Any, **kwargs: Any): ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __melobject__(self): ...
    def __apimfn__(self): ...
    def __radd__(self, other: Any): ...
    def __reduce__(self): ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __bool__(self) -> bool: ...
    def __lt__(self, other: Any) -> Any: ...
    def __gt__(self, other: Any) -> Any: ...
    def __le__(self, other: Any) -> Any: ...
    def __ge__(self, other: Any) -> Any: ...
    def stripNamespace(self, *args: Any, **kwargs: Any) -> other.NameParser: ...
    def swapNamespace(self, prefix: Any) -> other.NameParser: ...
    def namespaceList(self) -> List[str]: ...
    def addPrefix(self, prefix: Any) -> other.NameParser: ...
    def exists(self, **kwargs: Any): ...
    objExists: Any = ...
    nodeType: Any = ...
    def select(self, **kwargs: Any): ...
    def deselect(self) -> None: ...
    def listSets(self, *args: Any, **kwargs: Any) -> List[PyNode]: ...
    listConnections: Any = ...
    connections: Any = ...
    listHistory: Any = ...
    history: Any = ...
    listFuture: Any = ...
    future: Any = ...

deprecated_str_methods: Any
strDeprecateDecorator: Any

class Attribute:
    __apicls__: Any = ...
    attrItemReg: Any = ...
    def __apiobject__(self): ...
    def __apimobject__(self): ...
    def __apimplug__(self): ...
    def __apimdagpath__(self): ...
    def __apimattr__(self): ...
    def removeMultiInstance(self, index: Optional[Union[int, Iterable[int]]]=..., break_: bool=...) -> None: ...
    __delitem__: Any = ...
    def attr(self, attr: Any) -> Attribute: ...
    def __getattr__(self, attr: Any): ...
    def __call__(self, *args: Any, **kwargs: Any) -> None: ...
    def __iter__(self) -> Any: ...
    def __eq__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: Any) -> bool: ...
    def name(self, includeNode: Any=..., longName: Any=..., fullAttrPath: Any=..., fullDagPath: Any=..., placeHolderIndices: Any=...) -> str: ...
    def plugNode(self) -> nodetypes.DependNode: ...
    node: Any = ...
    def plugAttr(self, longName: Any=..., fullPath: Any=...) -> str: ...
    def lastPlugAttr(self, longName: Any=...) -> str: ...
    def longName(self, fullPath: Any=...) -> str: ...
    def shortName(self, fullPath: Any=...) -> str: ...
    def nodeName(self) -> str: ...
    def attrName(self, longName: bool = ..., includeNode: bool = ...): ...
    def namespace(self, *args: Any, **kwargs: Any): ...
    def array(self) -> Attribute: ...
    def elements(self) -> List[str]: ...
    def getArrayIndices(self) -> List[int]: ...
    def numElements(self) -> int: ...
    getEnums: Any = ...
    setEnums: Any = ...
    set: Any = ...
    get: Any = ...
    def isConnectedTo(self, other: Any, ignoreUnitConversion: Any=..., checkLocalArray: Any=..., checkOtherArray: Any=...) -> bool: ...
    connect: Any = ...
    def __rshift__(self, other: Any): ...
    disconnect: Any = ...
    def __floordiv__(self, other: Any) -> None: ...
    def inputs(self, **kwargs: Any) -> List[PyNode]: ...
    def outputs(self, **kwargs: Any) -> List[PyNode]: ...
    def insertInput(self, node: Any, nodeOutAttr: Any, nodeInAttr: Any) -> None: ...
    def setKey(self, **kwargs: Any): ...
    def getAlias(self, **kwargs: Any): ...
    def setAlias(self, alias: Any) -> None: ...
    def delete(self): ...
    def remove(self, **kwargs: Any): ...
    def isDirty(self, **kwargs: Any) -> bool: ...
    def setDirty(self, **kwargs: Any) -> None: ...
    def evaluate(self, **kwargs: Any) -> None: ...
    def affects(self) -> List[Attribute]: ...
    def affected(self) -> List[Attribute]: ...
    class _TempRealIndexedAttr:
        origAttr: Any = ...
        toDelete: Any = ...
        def __init__(self, attr: Any) -> None: ...
        chain: Any = ...
        def __enter__(self): ...
        def __exit__(self, type: Any, value: Any, traceback: Any) -> None: ...
    def type(self) -> str: ...
    def setLocked(self, locked: bool, checkReference: bool=...) -> None: ...
    def lock(self, checkReference: Any = ...): ...
    def unlock(self, checkReference: Any = ...): ...
    def isMuted(self) -> bool: ...
    def mute(self, **kwargs: Any) -> None: ...
    def unmute(self, **kwargs: Any) -> None: ...
    def isSettable(self) -> bool: ...
    def isHidden(self) -> bool: ...
    def isConnectable(self) -> bool: ...
    def isUsedAsColor(self) -> bool: ...
    def indexMatters(self): ...
    def exists(self) -> bool: ...
    def getDefault(self): ...
    def getSoftMin(self) -> Optional[float]: ...
    def getSoftMax(self) -> Optional[float]: ...
    def getMin(self) -> Optional[float]: ...
    def getMax(self) -> Optional[float]: ...
    def getSoftRange(self) -> List[float]: ...
    def getRange(self) -> List[float]: ...
    def setMin(self, newMin: Any) -> None: ...
    def setMax(self, newMax: Any) -> None: ...
    def setSoftMin(self, newMin: Any) -> None: ...
    def setSoftMax(self, newMax: Any) -> None: ...
    def setRange(self, *args: Any) -> None: ...
    def setSoftRange(self, *args: Any) -> None: ...
    def getChildren(self) -> List[Attribute]: ...
    children: Any = ...
    def iterDescendants(self, levels: Optional[int]=..., leavesOnly: bool=...) -> Iterator[Attribute]: ...
    def getSiblings(self) -> Optional[List[Attribute]]: ...
    siblings: Any = ...
    def firstParent(self): ...
    def getParent(self, generations: Any=..., arrays: Any=...) -> Attribute: ...
    def getAllParents(self, arrays: Any=...) -> List[Attribute]: ...
    parent: Any = ...
    FreeToChangeState: Any = ...
    MValueSelector: Any = ...
    def destinations(self) -> Tuple[bool, List[Attribute]]: ...
    def destinationsWithConversions(self) -> Tuple[bool, List[Attribute]]: ...
    def elementByLogicalIndex(self, index: int) -> Attribute: ...
    __getitem__: Any = ...
    def elementByPhysicalIndex(self, index: int) -> Attribute: ...
    def evaluateNumElements(self) -> int: ...
    def getNumElements(self) -> int: ...
    def getSetAttrCmds(self, valueSelector: datatypes.Plug.MValueSelector=..., useLongNames: bool=...) -> List[str]: ...
    def info(self) -> str: ...
    def isArray(self) -> bool: ...
    isMulti: Any = ...
    def isCaching(self) -> bool: ...
    def isChild(self) -> bool: ...
    def isCompound(self) -> bool: ...
    def isConnected(self) -> bool: ...
    def isDefaultValue(self, forceEval: bool=...) -> bool: ...
    def isDestination(self) -> bool: ...
    def isDynamic(self) -> bool: ...
    def isElement(self) -> bool: ...
    def isFreeToChange(self, checkParents: bool=..., checkChildren: bool=...) -> datatypes.Plug.FreeToChangeState: ...
    def isFromReferencedFile(self) -> bool: ...
    def isIgnoredWhenRendering(self) -> bool: ...
    def isInChannelBox(self) -> bool: ...
    def isKeyable(self) -> bool: ...
    def isLocked(self) -> bool: ...
    def isNetworked(self) -> bool: ...
    def isNull(self) -> bool: ...
    def isProcedural(self) -> bool: ...
    def isSource(self) -> bool: ...
    def logicalIndex(self) -> int: ...
    item: Any = ...
    index: Any = ...
    def numChildren(self) -> int: ...
    def numConnectedChildren(self) -> int: ...
    def numConnectedElements(self) -> int: ...
    def setCaching(self, isCaching: bool) -> None: ...
    def setKeyable(self, keyable: bool) -> None: ...
    def setNumElements(self, elements: int) -> None: ...
    def showInChannelBox(self, inChannelBox: bool) -> None: ...
    def source(self) -> Attribute: ...
    def sourceWithConversion(self) -> Attribute: ...
ProxySlice = slice

class HashableSlice(ProxySlice):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __hash__(self) -> Any: ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...
    def __le__(self, other: Any) -> Any: ...
    def __lt__(self, other: Any) -> Any: ...
    def __ge__(self, other: Any) -> Any: ...
    def __gt__(self, other: Any) -> Any: ...
    @property
    def start(self): ...
    @property
    def stop(self): ...
    @property
    def step(self): ...

class Component:
    _apienum__: Any = ...
    _ComponentLabel__: str = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __apimdagpath__(self): ...
    def __apimobject__(self): ...
    def __apiobject__(self): ...
    def __apihandle__(self): ...
    def __apicomponent__(self): ...
    def __apimfn__(self): ...
    def __eq__(self, other: Any) -> Any: ...
    def __bool__(self) -> bool: ...
    def __melobject__(self): ...
    def name(self) -> str: ...
    def node(self): ...
    def namespace(self, *args: Any, **kwargs: Any): ...
    plugNode: Any = ...
    def plugAttr(self): ...
    def isComplete(self, *args: Any, **kwargs: Any): ...
    @staticmethod
    def numComponentsFromStrings(*componentStrings: Any): ...

class DimensionedComponent(Component):
    dimensions: int = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    VALID_SINGLE_INDEX_TYPES: Any = ...
    def __getitem__(self, item: Any): ...
    def currentDimension(self): ...

class ComponentIndex(tuple):
    label: Any = ...
    def __new__(cls, *args: Any, **kwargs: Any): ...
    def __add__(self, other: Any): ...

def validComponentIndexType(argObj: Any, allowDicts: bool = ..., componentIndexTypes: Optional[Any] = ...): ...

class DiscreteComponent(DimensionedComponent):
    VALID_SINGLE_INDEX_TYPES: Any = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __iter__(self) -> Any: ...
    indicesIter: Any = ...
    def indices(self): ...
    def __len__(self): ...
    def count(self): ...
    def totalSize(self): ...
    def setIndex(self, index: Any): ...
    def getIndex(self): ...
    def currentItem(self): ...
    def currentItemIndex(self): ...
    def __next__(self): ...
    def reset(self) -> None: ...

class ContinuousComponent(DimensionedComponent):
    VALID_SINGLE_INDEX_TYPES: Any = ...
    def __iter__(self) -> Any: ...

class Component1DFloat(ContinuousComponent):
    dimensions: int = ...
    def index(self): ...

class Component2DFloat(ContinuousComponent):
    dimensions: int = ...

class Component1D(DiscreteComponent):
    _apienum__: Any = ...
    dimensions: int = ...
    def index(self): ...
    def name(self) -> str: ...
    def currentItem(self): ...
    def currentItemIndex(self): ...
    def indicesIter(self) -> None: ...
    def __add__(self, other: Any): ...
    def __iadd__(self, other: Any): ...

class Component2D(DiscreteComponent):
    _apienum__: Any = ...
    dimensions: int = ...

class Component3D(DiscreteComponent):
    _apienum__: Any = ...
    dimensions: int = ...

class MItComponent(Component):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __apimit__(self, alwaysUnindexed: bool = ...): ...
    def __apimfn__(self): ...

class MItComponent1D(MItComponent, Component1D): ...

class Component1D64(DiscreteComponent):
    _apienum__: Any = ...
    def totalSize(self) -> None: ...
    def __len__(self): ...
    dimensions: int = ...

class MeshVertex(MItComponent1D):
    __apicls__: Any = ...
    _ComponentLabel__: str = ...
    _apienum__: Any = ...
    def setColor(self, color: Any) -> None: ...
    def connectedEdges(self) -> List[MeshEdge]: ...
    def connectedFaces(self) -> List[MeshFace]: ...
    def connectedVertices(self) -> List[MeshVertex]: ...
    def isConnectedTo(self, component: Any) -> bool: ...
    def getColor(self, *args: Any, **kwargs: Any) -> datatypes.Color: ...
    def geomChanged(self) -> None: ...
    def getColorIndices(self, colorSetName: str=...) -> List[int]: ...
    def getColors(self, colorSetName: str=...) -> List[datatypes.Color]: ...
    def getNormal(self, space: datatypes.Space.Space=...) -> datatypes.Vector: ...
    def getNormalIndices(self) -> List[int]: ...
    def getNormals(self, space: datatypes.Space.Space=...) -> List[datatypes.Vector]: ...
    def getPosition(self, space: datatypes.Space.Space=...) -> datatypes.Point: ...
    def getUV(self, uvSet: str=...) -> Tuple[float, float]: ...
    def getUVIndices(self, uvSet: str=...) -> List[int]: ...
    def getUVs(self, uvSet: str=...) -> Tuple[List[float], List[float], List[int]]: ...
    def hasColor(self) -> bool: ...
    def isConnectedToEdge(self, index: int) -> bool: ...
    def isConnectedToFace(self, index: int) -> bool: ...
    def isOnBoundary(self) -> bool: ...
    def numConnectedEdges(self) -> int: ...
    def numConnectedFaces(self) -> int: ...
    def numUVs(self, uvSet: str=...) -> int: ...
    def setPosition(self, point: datatypes.Point, space: datatypes.Space.Space=...) -> None: ...
    def setUV(self, uvPoint: Tuple[float, float], uvSet: str=...) -> None: ...
    def setUVs(self, uArray: List[float], vArray: List[float], faceIds: List[int], uvSet: str=...) -> None: ...
    def translateBy(self, vector: datatypes.Vector, space: datatypes.Space.Space=...) -> None: ...
    def updateSurface(self) -> None: ...

class MeshEdge(MItComponent1D):
    __apicls__: Any = ...
    _ComponentLabel__: str = ...
    _apienum__: Any = ...
    def connectedEdges(self) -> List[MeshEdge]: ...
    def connectedFaces(self) -> List[MeshFace]: ...
    def connectedVertices(self) -> Tuple[MeshVertex, MeshVertex]: ...
    def isConnectedTo(self, component: Union[MeshFace, MeshEdge, MeshVertex]) -> bool: ...
    def getLength(self, space: datatypes.Space.Space=...) -> float: ...
    def getPoint(self, index: int, space: datatypes.Space.Space=...) -> datatypes.Point: ...
    def isConnectedToEdge(self, index: int) -> bool: ...
    def isConnectedToFace(self, index: int) -> bool: ...
    def isOnBoundary(self) -> bool: ...
    def isSmooth(self) -> bool: ...
    def numConnectedEdges(self) -> int: ...
    def numConnectedFaces(self) -> int: ...
    def setPoint(self, point: datatypes.Point, index: int, space: datatypes.Space.Space=...) -> None: ...
    def setSmoothing(self, smooth: bool=...) -> None: ...
    def updateSurface(self) -> None: ...

class MeshFace(MItComponent1D):
    __apicls__: Any = ...
    _ComponentLabel__: str = ...
    _apienum__: Any = ...
    def connectedEdges(self) -> List[MeshEdge]: ...
    def connectedFaces(self) -> List[MeshFace]: ...
    def connectedVertices(self) -> List[MeshVertex]: ...
    def isConnectedTo(self, component: Union[MeshFace, MeshEdge, MeshVertex]) -> bool: ...
    def geomChanged(self) -> None: ...
    def getArea(self, space: datatypes.Space.Space=...) -> float: ...
    def getAxisAtUV(self, uvPoint: Tuple[float, float], space: datatypes.Space.Space=..., uvSet: str=..., tolerance: float=...) -> Tuple[datatypes.Vector, datatypes.Vector, datatypes.Vector]: ...
    def getColor(self, colorSetName: str=...) -> datatypes.Color: ...
    def getColorIndex(self, vertexIndex: int, colorSetName: str=...) -> int: ...
    def getColorIndices(self, colorSetName: str=...) -> List[int]: ...
    def getColors(self, colorSetName: str=...) -> List[datatypes.Color]: ...
    def getEdges(self) -> List[int]: ...
    def getNormal(self, space: datatypes.Space.Space=...) -> datatypes.Vector: ...
    def getNormals(self, space: datatypes.Space.Space=...) -> List[datatypes.Vector]: ...
    def getPoint(self, index: int, space: datatypes.Space.Space=...) -> datatypes.Point: ...
    def getPointAtUV(self, uvPoint: Tuple[float, float], space: datatypes.Space.Space=..., uvSet: str=..., tolerance: float=...) -> datatypes.Point: ...
    def getPoints(self, space: datatypes.Space.Space=...) -> List[datatypes.Point]: ...
    def getUV(self, vertex: int, uvSet: str=...) -> Tuple[float, float]: ...
    def getUVArea(self, uvSet: str=...) -> float: ...
    def getUVAtPoint(self, pt: datatypes.Point, space: datatypes.Space.Space=..., uvSet: str=...) -> Tuple[float, float]: ...
    def getUVIndex(self, vertex: int, uvSet: str=...) -> int: ...
    def getUVSetNames(self) -> List[str]: ...
    def getUVs(self, uvSet: str=...) -> Tuple[List[float], List[float]]: ...
    def getVertices(self) -> List[int]: ...
    def hasColor(self) -> bool: ...
    def hasUVs(self) -> bool: ...
    def hasValidTriangulation(self) -> bool: ...
    def isConnectedToEdge(self, index: int) -> bool: ...
    def isConnectedToFace(self, index: int) -> bool: ...
    def isConnectedToVertex(self, index: int) -> bool: ...
    def isConvex(self) -> bool: ...
    def isHoled(self) -> bool: ...
    def isLamina(self) -> bool: ...
    def isOnBoundary(self) -> bool: ...
    def isPlanar(self) -> bool: ...
    def isStarlike(self) -> bool: ...
    def isUVReversed(self, uvSet: str=...) -> bool: ...
    def isZeroArea(self) -> bool: ...
    def isZeroUVArea(self) -> bool: ...
    def normalIndex(self, localVertexIndex: int) -> int: ...
    def numColors(self, colorSetName: str=...) -> int: ...
    def numConnectedEdges(self) -> int: ...
    def numConnectedFaces(self) -> int: ...
    def numTriangles(self) -> int: ...
    def polygonVertexCount(self) -> int: ...
    def setPoint(self, point: datatypes.Point, index: int, space: datatypes.Space.Space=...) -> None: ...
    def setPoints(self, pointArray: List[datatypes.Point], space: datatypes.Space.Space=...) -> None: ...
    def setUV(self, vertexId: int, uvPoint: Tuple[float, float], uvSet: str=...) -> None: ...
    def setUVs(self, uArray: List[float], vArray: List[float], uvSet: str=...) -> None: ...
    def updateSurface(self) -> None: ...

class MeshUV(Component1D):
    _ComponentLabel__: str = ...
    _apienum__: Any = ...

class MeshVertexFace(Component2D):
    _ComponentLabel__: str = ...
    _apienum__: Any = ...
    def __melobject__(self): ...
    def totalSize(self): ...

class SubdVertex(Component1D64):
    _ComponentLabel__: str = ...
    _apienum__: Any = ...

class SubdEdge(Component1D64):
    _ComponentLabel__: str = ...
    _apienum__: Any = ...

class SubdFace(Component1D64):
    _ComponentLabel__: str = ...
    _apienum__: Any = ...

class SubdUV(Component1D):
    _ComponentLabel__: str = ...
    _apienum__: Any = ...
    def totalSize(self) -> None: ...

class NurbsCurveParameter(Component1DFloat):
    _ComponentLabel__: str = ...
    _apienum__: Any = ...

class NurbsCurveCV(MItComponent1D):
    __apicls__: Any = ...
    _ComponentLabel__: str = ...
    _apienum__: Any = ...
    def getPosition(self, space: datatypes.Space.Space=...) -> datatypes.Point: ...
    def hasHistoryOnCreate(self) -> bool: ...
    def isDone(self) -> bool: ...
    def setPosition(self, pt: datatypes.Point, space: datatypes.Space.Space=...) -> None: ...
    def translateBy(self, vec: datatypes.Vector, space: datatypes.Space.Space=...) -> None: ...
    def updateCurve(self) -> None: ...

class NurbsCurveEP(Component1D):
    _ComponentLabel__: str = ...
    _apienum__: Any = ...

class NurbsCurveKnot(Component1D):
    _ComponentLabel__: str = ...
    _apienum__: Any = ...

class NurbsSurfaceIsoparm(Component2DFloat):
    _ComponentLabel__: Any = ...
    _apienum__: Any = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...

class NurbsSurfaceRange(NurbsSurfaceIsoparm):
    _ComponentLabel__: Any = ...
    _apienum__: Any = ...

class NurbsSurfaceCV(Component2D):
    _ComponentLabel__: str = ...
    _apienum__: Any = ...

class NurbsSurfaceEP(Component2D):
    _ComponentLabel__: str = ...
    _apienum__: Any = ...

class NurbsSurfaceKnot(Component2D):
    _ComponentLabel__: str = ...
    _apienum__: Any = ...

class NurbsSurfaceFace(Component2D):
    _ComponentLabel__: str = ...
    _apienum__: Any = ...

class LatticePoint(Component3D):
    _ComponentLabel__: str = ...
    _apienum__: Any = ...

class Pivot(Component):
    _ComponentLabel__: Any = ...
    _apienum__: Any = ...

class ParticleComponent(Component1D):
    _ComponentLabel__: str = ...
    _apienum__: Any = ...
    def attr(self, attr: Any): ...
    def __getattr__(self, attr: Any): ...

class AttributeSpec:
    __apicls__: Any = ...
    def __new__(cls, *args: Any, **kwargs: Any): ...
    def __apiobject__(self): ...
    def __apimobject__(self): ...
    def __apimplug__(self): ...
    def __apimdagpath__(self): ...
    def name(self) -> str: ...
    def parent(self): ...
    DisconnectBehavior: Any = ...
    def accepts(self, type: nt.Data.Type) -> bool: ...
    def addToCategory(self, category: str) -> None: ...
    def getAddAttrCmd(self, useLongName: bool=...) -> str: ...
    def getAffectsAppearance(self) -> bool: ...
    def getCategories(self) -> List[str]: ...
    def getDisconnectBehavior(self) -> nt.Attribute.DisconnectBehavior: ...
    def getIndexMatters(self) -> bool: ...
    def getInternal(self) -> bool: ...
    def getUsesArrayDataBuilder(self) -> bool: ...
    def hasCategory(self, category: str) -> bool: ...
    def isAffectsWorldSpace(self) -> bool: ...
    def isArray(self) -> bool: ...
    def isCached(self) -> bool: ...
    def isChannelBoxFlagSet(self) -> bool: ...
    def isConnectable(self) -> bool: ...
    def isDynamic(self) -> bool: ...
    def isExtension(self) -> bool: ...
    def isHidden(self) -> bool: ...
    def isIndeterminant(self) -> bool: ...
    def isKeyable(self) -> bool: ...
    def isProxyAttribute(self) -> bool: ...
    def isReadable(self) -> bool: ...
    def isRenderSource(self) -> bool: ...
    def isStorable(self) -> bool: ...
    def isUsedAsColor(self) -> bool: ...
    def isUsedAsFilename(self) -> bool: ...
    def isWorldSpace(self) -> bool: ...
    def isWritable(self) -> bool: ...
    def removeFromCategory(self, category: str) -> None: ...
    def setAffectsAppearance(self, state: bool) -> None: ...
    def setAffectsWorldSpace(self, state: bool) -> None: ...
    def setArray(self, state: bool) -> None: ...
    def setCached(self, state: bool) -> None: ...
    def setChannelBox(self, state: bool) -> None: ...
    def setConnectable(self, state: bool) -> None: ...
    def setDisconnectBehavior(self, behavior: nt.Attribute.DisconnectBehavior) -> None: ...
    def setHidden(self, state: bool) -> None: ...
    def setIndeterminant(self, state: bool) -> None: ...
    def setIndexMatters(self, state: bool) -> None: ...
    def setInternal(self, state: bool) -> None: ...
    def setKeyable(self, state: bool) -> None: ...
    def setNiceNameOverride(self, localizedName: str) -> None: ...
    def setProxyAttribute(self, state: bool) -> None: ...
    def setReadable(self, state: bool) -> None: ...
    def setRenderSource(self, state: bool) -> None: ...
    def setStorable(self, state: bool) -> None: ...
    def setUsedAsColor(self, state: bool) -> None: ...
    def setUsedAsFilename(self, state: bool) -> None: ...
    def setUsesArrayDataBuilder(self, state: bool) -> None: ...
    def setWorldSpace(self, state: bool) -> None: ...
    def setWritable(self, state: bool) -> None: ...
    def shortName(self) -> str: ...
AttributeDefaults = AttributeSpec

class Scene:
    def __getattr__(self, obj: Any): ...

SCENE: Any
about: Any
addExtension: Any
affectedNet: Any
affects: Any
aliasAttr: Any
align: Any
applyAttrPattern: Any
artAttrTool: Any

def assembly(*args: Any, **kwargs: Any): ...

attributeInfo: Any
attributeName: Any
attributeQuery: Any
bakePartialHistory: Any
baseTemplate: Any
baseView: Any
color: Any
colorIndex: Any
colorManagementCatalog: Any
colorManagementConvert: Any
colorManagementFileRules: Any
colorManagementPrefs: Any

def commandLogging(*args: Any, **kwargs: Any): ...
def commandPort(*args: Any, **kwargs: Any): ...

connectionInfo: Any

def container(*args: Any, **kwargs: Any): ...

containerBind: Any
containerProxy: Any
containerPublish: Any
containerTemplate: Any
containerView: Any
contextInfo: Any
copyAttr: Any
createAttrPatterns: Any

def createDisplayLayer(*args: Any, **kwargs: Any): ...

currentUnit: Any
curveRGBColor: Any
cycleCheck: Any
deleteAttr: Any
deleteAttrPattern: Any
deleteExtension: Any
displayAffected: Any
displayColor: Any
displayCull: Any
displayLevelOfDetail: Any
displayPref: Any
displayRGBColor: Any
displaySmoothness: Any
displayStats: Any
displaySurface: Any

def distanceDimension(*args: Any, **kwargs: Any): ...

editDisplayLayerGlobals: Any
editDisplayLayerMembers: Any
exactWorldBoundingBox: Any
expandedSelection: Any
filterInstances: Any
geometryAttrInfo: Any
hide: Any
hilite: Any
inheritTransform: Any

def instance(*args: Any, **kwargs: Any): ...

instanceable: Any
isConnected: Any
isDirty: Any
isolateSelect: Any
license: Any

def listAttr(*args: Any, **kwargs: Any): ...

listAttrPatterns: Any
listNodeTypes: Any
listNodesWithIncorrectNames: Any
lockNode: Any
makeIdentity: Any
makeLive: Any
makePaintable: Any
matchTransform: Any
nodeCast: Any
objExists: Any
objectCenter: Any
objectType: Any

def paramDimension(*args: Any, **kwargs: Any): ...

paramLocator: Any

def partition(*args: Any, **kwargs: Any): ...

performanceOptions: Any
pickWalk: Any
pixelMove: Any
polySplitCtx2: Any
relationship: Any
removeMultiInstance: Any
renameAttr: Any
reorder: Any
reorderContainer: Any
resetTool: Any
saveToolSettings: Any
scaleComponents: Any
sceneLint: Any
sculptMeshCacheChangeCloneSource: Any

def selectKey(*args: Any, **kwargs: Any): ...

selectMode: Any
selectPref: Any
selectPriority: Any
selectType: Any
selectedNodes: Any
setToolTo: Any
shapeCompare: Any
showHidden: Any
snapMode: Any
softSelect: Any
suitePrefs: Any
symmetricModelling: Any
threadCount: Any
timeCode: Any
toggle: Any
toggleAxis: Any
toggleDisplacement: Any
toolDropped: Any
toolHasOptions: Any

def toolPropertyWindow(*args: Any, **kwargs: Any): ...

transformCompare: Any
transformLimits: Any
ungroup: Any
upAxis: Any
xform: Any
xformConstraint: Any
encodeString: Any
format: Any

def assignCommand(*args: Any, **kwargs: Any): ...

commandEcho: Any

def condition(*args: Any, **kwargs: Any): ...

evalDeferred: Any
isTrue: Any
itemFilter: Any
itemFilterAttr: Any
itemFilterRender: Any
itemFilterType: Any
pause: Any
refresh: Any
stringArrayIntersector: Any

def selectionConnection(*args: Any, **kwargs: Any): ...
