from pymel.util.arrays import *
from typing import *
import pymel.internal.factories as _factories
from pymel.util.enum import Enum as Enum
from typing import Any, Optional

class MetaMayaArrayTypeWrapper(_factories.MetaMayaTypeRegistry):
    def __new__(mcl: Any, classname: Any, bases: Any, classdict: Any): ...

class Vector:
    apicls: Any = ...
    cnames: Any = ...
    shape: Any = ...
    unit: Any = ...
    def __new__(cls, *args: Any, **kwargs: Any): ...
    def __init__(self, *args: Any, **kwargs: Any): ...
    data: Any = ...
    def assign(self, value: Any): ...
    def get(self): ...
    def __len__(self): ...
    def __getitem__(self, i: Any): ...
    def __setitem__(self, i: Any, a: Any) -> None: ...
    def __iter__(self, *args: Any, **kwargs: Any) -> Any: ...
    def __contains__(self, value: Any): ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...
    def __neg__(self): ...
    def __add__(self, other: Any): ...
    def __radd__(self, other: Any): ...
    def __iadd__(self, other: Any): ...
    def __sub__(self, other: Any): ...
    def __rsub__(self, other: Any): ...
    def __isub__(self, other: Any): ...
    def __truediv__(self, other: Any): ...
    __div__: Any = ...
    def __rtruediv__(self, other: Any): ...
    __rdiv__: Any = ...
    def __itruediv__(self, other: Any): ...
    __idiv__: Any = ...
    def __mul__(self, other: Any): ...
    def __rmul__(self, other: Any): ...
    def __imul__(self, other: Any): ...
    def __xor__(self, other: Any): ...
    def __ixor__(self, other: Any): ...
    def isEquivalent(self, other: Any, tol: Optional[Any] = ...): ...
    def isParallel(self, other: Any, tol: Optional[Any] = ...): ...
    def distanceTo(self, other: Any): ...
    def length(self): ...
    def sqlength(self): ...
    def normal(self): ...
    def normalize(self) -> None: ...
    def rotateTo(self, other: Any): ...
    def rotateBy(self, *args: Any): ...
    def transformAsNormal(self, other: Any): ...
    def dot(self, other: Any): ...
    def cross(self, other: Any): ...
    def axis(self, other: Any, normalize: bool = ...): ...
    def angle(self, other: Any): ...
    def cotan(self, other: Any): ...
    __setattr__: Any = ...
    Axis: Any = ...
    one: Any = ...
    xAxis: Any = ...
    xNegAxis: Any = ...
    yAxis: Any = ...
    yNegAxis: Any = ...
    zAxis: Any = ...
    zNegAxis: Any = ...
    zero: Any = ...

class FloatVector(Vector):
    apicls: Any = ...
    __setattr__: Any = ...
    one: Any = ...
    xAxis: Any = ...
    xNegAxis: Any = ...
    yAxis: Any = ...
    yNegAxis: Any = ...
    zAxis: Any = ...
    zNegAxis: Any = ...
    zero: Any = ...

def planar(p: Any, *args: Any, **kwargs: Any): ...
def center(p: Any, *args: Any): ...
def bWeights(p: Any, *args: Any): ...

class Point(Vector):
    apicls: Any = ...
    cnames: Any = ...
    shape: Any = ...
    def __melobject__(self): ...
    def __len__(self): ...
    def __iter__(self, *args: Any, **kwargs: Any) -> Any: ...
    def __add__(self, other: Any): ...
    def __radd__(self, other: Any): ...
    def __iadd__(self, other: Any): ...
    def cartesianize(self): ...
    def cartesian(self): ...
    def rationalize(self): ...
    def rational(self): ...
    def homogenize(self): ...
    def homogen(self): ...
    def isEquivalent(self, other: Any, tol: Optional[Any] = ...): ...
    def axis(self, start: Any, end: Any, normalize: bool = ...): ...
    def angle(self, start: Any, end: Any): ...
    def cotan(self, start: Any, end: Any): ...
    def planar(self, *args: Any, **kwargs: Any): ...
    def center(self, *args: Any): ...
    def bWeights(self, *args: Any): ...
    __setattr__: Any = ...
    origin: Any = ...

class FloatPoint(Point):
    apicls: Any = ...
    __setattr__: Any = ...
    origin: Any = ...
    def setCast(self, srcpt: Point) -> None: ...

class Color(Vector):
    apicls: Any = ...
    cnames: Any = ...
    shape: Any = ...
    modes: Any = ...
    red: Any = ...
    green: Any = ...
    blue: Any = ...
    white: Any = ...
    black: Any = ...
    opaque: Any = ...
    clear: Any = ...
    @staticmethod
    def rgbtohsv(c: Any): ...
    @staticmethod
    def hsvtorgb(c: Any): ...
    rgba: Any = ...
    rgb: Any = ...
    hsva: Any = ...
    hsv: Any = ...
    h: Any = ...
    s: Any = ...
    v: Any = ...
    def __init__(self, *args: Any, **kwargs: Any): ...
    def __melobject__(self): ...
    def __add__(self, other: Any): ...
    def __radd__(self, other: Any): ...
    def __iadd__(self, other: Any): ...
    def __sub__(self, other: Any): ...
    def __rsub__(self, other: Any): ...
    def __isub__(self, other: Any): ...
    def __mul__(self, other: Any): ...
    def __rmul__(self, other: Any): ...
    def __imul__(self, other: Any): ...
    def over(self, other: Any): ...
    def premult(self): ...
    def gamma(self, g: Any): ...
    def hsvblend(self, other: Any, weight: float = ...): ...
    __setattr__: Any = ...
    MColorType: Any = ...
    kOpaqueBlack: Any = ...
    def set(self, colorModel: Color.MColorType, c1: float, c2: float, c3: float, alpha: float=...) -> bool: ...

class Space:
    apicls: Any = ...
    Space: Any = ...

Spaces: Any

def equivalentSpace(space1: Union[int, str], space2: Union[int, str], rotationOnly: bool=...) -> None: ...

class Matrix:
    apicls: Any = ...
    shape: Any = ...
    cnames: Any = ...
    identity: Any = ...
    def __new__(cls, *args: Any, **kwargs: Any): ...
    def __init__(self, *args: Any, **kwargs: Any): ...
    data: Any = ...
    translate: Any = ...
    rotate: Any = ...
    scale: Any = ...
    def __melobject__(self): ...
    def asMatrix(self, percent: Optional[Any] = ...): ...
    matrix: Any = ...
    def assign(self, value: Any): ...
    def get(self): ...
    def __len__(self): ...
    def __iter__(self, *args: Any, **kwargs: Any) -> Any: ...
    def __getitem__(self, index: Any): ...
    def __getslice__(self, start: Any, end: Any): ...
    def __setitem__(self, index: Any, value: Any) -> None: ...
    def __setslice__(self, start: Any, end: Any, value: Any) -> None: ...
    def __delitem__(self, index: Any) -> None: ...
    def __delslice__(self, start: Any, end: Any) -> None: ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...
    def __neg__(self): ...
    def __add__(self, other: Any): ...
    def __radd__(self, other: Any): ...
    def __iadd__(self, other: Any): ...
    def __sub__(self, other: Any): ...
    def __rsub__(self, other: Any): ...
    def __isub__(self, other: Any): ...
    def __mul__(self, other: Any): ...
    def __rmul__(self, other: Any): ...
    def __imul__(self, other: Any): ...
    def setToIdentity(self): ...
    def setToProduct(self, left: Any, right: Any): ...
    def transpose(self): ...
    def inverse(self): ...
    def adjoint(self): ...
    def homogenize(self): ...
    def det(self): ...
    def det4x4(self): ...
    def det3x3(self): ...
    def isEquivalent(self, other: Any, tol: Any = ...): ...
    def isSingular(self): ...
    def blend(self, other: Any, weight: float = ...): ...
    def weighted(self, weight: Any): ...
    __setattr__: Any = ...

class FloatMatrix(Matrix):
    apicls: Any = ...
    __setattr__: Any = ...

class Quaternion(Matrix):
    apicls: Any = ...
    shape: Any = ...
    cnames: Any = ...
    def __new__(cls, *args: Any, **kwargs: Any): ...
    unit: str = ...
    def __init__(self, *args: Any, **kwargs: Any): ...
    translate: Any = ...
    rotate: Any = ...
    scale: Any = ...
    def assign(self, value: Any): ...
    def get(self): ...
    def __getitem__(self, i: Any): ...
    def __setitem__(self, i: Any, a: Any) -> None: ...
    def __iter__(self) -> Any: ...
    def __len__(self): ...
    def __contains__(self, value: Any): ...
    __setattr__: Any = ...
    identity: Any = ...
    def asEulerRotation(self) -> EulerRotation: ...
    def conjugateIt(self) -> Quaternion: ...
    def exp(self) -> Quaternion: ...
    def invertIt(self) -> Quaternion: ...
    def log(self) -> Quaternion: ...
    def negateIt(self) -> Quaternion: ...
    def normalizeIt(self) -> Quaternion: ...
    def scaleIt(self, scale: float) -> Quaternion: ...
    def setToXAxis(self, theta: float) -> Quaternion: ...
    def setToYAxis(self, theta: float) -> Quaternion: ...
    def setToZAxis(self, theta: float) -> Quaternion: ...

class TransformationMatrix(Matrix):
    apicls: Any = ...
    translate: Any = ...
    rotate: Any = ...
    def rotateTo(self, value: Any): ...
    def eulerRotation(self): ...
    euler: Any = ...
    def getRotation(self): ...
    def setRotation(self, *args: Any) -> None: ...
    scale: Any = ...
    RotationOrder: Any = ...
    identity: Any = ...
    def __getattribute__(self, name: Any): ...
    def addRotation(self, rot: Tuple[float, float, float], order: TransformationMatrix.RotationOrder, space: Space.Space) -> None: ...
    def addRotationQuaternion(self, x: float, y: float, z: float, w: float, space: Space.Space) -> None: ...
    def addScale(self, scale: Tuple[float, float, float], space: Space.Space) -> None: ...
    def addShear(self, shear: Tuple[float, float, float], space: Space.Space) -> None: ...
    def addTranslation(self, vector: Vector, space: Space.Space) -> None: ...
    def asMatrixInverse(self) -> Matrix: ...
    def asRotateMatrix(self) -> Matrix: ...
    def asScaleMatrix(self) -> Matrix: ...
    def getRotatePivot(self, space: Space.Space) -> Point: ...
    def getRotatePivotTranslation(self, space: Space.Space) -> Vector: ...
    def getRotationOrientation(self) -> Quaternion: ...
    def getRotationQuaternion(self) -> Tuple[float, float, float, float]: ...
    def getScale(self, space: Space.Space) -> Tuple[float, float, float]: ...
    def getScalePivot(self, space: Space.Space) -> Point: ...
    def getScalePivotTranslation(self, space: Space.Space) -> Vector: ...
    def getShear(self, space: Space.Space) -> Tuple[float, float, float]: ...
    def getTranslation(self, space: Space.Space) -> Vector: ...
    def reorderRotation(self, order: TransformationMatrix.RotationOrder) -> None: ...
    def rotateBy(self, q: Quaternion, space: Space.Space) -> TransformationMatrix: ...
    def rotationOrder(self) -> TransformationMatrix.RotationOrder: ...
    def setRotatePivot(self, point: Point, space: Space.Space, balance: bool) -> None: ...
    def setRotatePivotTranslation(self, vector: Vector, space: Space.Space) -> None: ...
    def setRotationOrientation(self, q: Quaternion) -> TransformationMatrix: ...
    def setRotationQuaternion(self, x: float, y: float, z: float, w: float) -> None: ...
    def setScale(self, scale: Tuple[float, float, float], space: Space.Space) -> None: ...
    def setScalePivot(self, point: Point, space: Space.Space, balance: bool) -> None: ...
    def setScalePivotTranslation(self, vector: Vector, space: Space.Space) -> None: ...
    def setShear(self, shear: Tuple[float, float, float], space: Space.Space) -> None: ...
    def setToRotationAxis(self, axis: Vector, rotation: float) -> None: ...
    def setTranslation(self, vector: Vector, space: Space.Space) -> None: ...

class EulerRotation:
    apicls: Any = ...
    shape: Any = ...
    cnames: Any = ...
    order: Any = ...
    def __new__(cls, *args: Any, **kwargs: Any): ...
    unit: Any = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def setDisplayUnit(self, unit: Any) -> None: ...
    def __iter__(self) -> Any: ...
    def __getitem__(self, i: Any): ...
    def __setitem__(self, key: Any, val: Any) -> None: ...
    def assign(self, *args: Any, **kwargs: Any): ...
    def get(self): ...
    def __contains__(self, value: Any): ...
    def __len__(self): ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...
    def __neg__(self): ...
    def __add__(self, other: Any): ...
    def __radd__(self, other: Any): ...
    def __iadd__(self, other: Any): ...
    def __sub__(self, other: Any): ...
    def __rsub__(self, other: Any): ...
    def __isub__(self, other: Any): ...
    def __truediv__(self, other: Any): ...
    __div__: Any = ...
    def __rtruediv__(self, other: Any): ...
    __rdiv__: Any = ...
    def __itruediv__(self, other: Any): ...
    __idiv__: Any = ...
    def __mul__(self, other: Any): ...
    def __rmul__(self, other: Any): ...
    def __imul__(self, other: Any): ...
    __setattr__: Any = ...
    RotationOrder: Any = ...
    identity: Any = ...
    def alternateSolution(self) -> EulerRotation: ...
    def asMatrix(self) -> Matrix: ...
    def asQuaternion(self) -> Quaternion: ...
    def asVector(self) -> Vector: ...
    def bound(self) -> EulerRotation: ...
    def boundIt(self, src: EulerRotation) -> EulerRotation: ...
    def closestCut(self, dst: EulerRotation) -> EulerRotation: ...
    def closestSolution(self, dst: EulerRotation) -> EulerRotation: ...
    @classmethod
    def decompose(self, matrix: Matrix, ord: EulerRotation.RotationOrder) -> EulerRotation: ...
    def incrementalRotateBy(self, axis: Vector, angle: float) -> EulerRotation: ...
    def inverse(self) -> EulerRotation: ...
    def invertIt(self) -> EulerRotation: ...
    def isZero(self, tolerance: float=...) -> bool: ...
    def reorder(self, ord: EulerRotation.RotationOrder) -> EulerRotation: ...
    def reorderIt(self, ord: EulerRotation.RotationOrder) -> EulerRotation: ...
    def setToAlternateSolution(self, src: EulerRotation) -> EulerRotation: ...
    def setToClosestCut(self, src: EulerRotation, dst: EulerRotation) -> EulerRotation: ...
    def setToClosestSolution(self, src: EulerRotation, dst: EulerRotation) -> EulerRotation: ...
    def setValue(self, v: Vector, ord: EulerRotation.RotationOrder=...) -> EulerRotation: ...

class Unit(float):
    @classmethod
    def getUIUnit(cls): ...
    @classmethod
    def setUIUnit(cls, unit: Optional[Any] = ...) -> None: ...
    @classmethod
    def getInternalUnit(cls): ...
    @classmethod
    def uiToInternal(cls, value: Any): ...
    @classmethod
    def kUnit(cls, unit: Optional[Any] = ...): ...
    @classmethod
    def sUnit(cls, unit: Optional[Any] = ...): ...
    def getUnit(self): ...
    unit: Any = ...
    def __new__(cls, value: Any, unit: Optional[Any] = ...): ...
    def assign(self, *args: Any) -> None: ...
    def asUnit(self, unit: Any): ...
    def asUIUnit(self): ...
    def asInternalUnit(self): ...

class Time(Unit):
    apicls: Any = ...
    Unit: Any = ...

class Distance(Unit):
    apicls: Any = ...
    def asMillimeter(self): ...
    def asCentimeters(self): ...
    def asKilometers(self): ...
    def asMeters(self): ...
    def asInches(self): ...
    def asFeet(self): ...
    def asYards(self): ...
    def asMiles(self): ...
    Unit: Any = ...

class Angle(Unit):
    apicls: Any = ...
    def asRadians(self): ...
    def asDegrees(self): ...
    def asAngMinutes(self): ...
    def asAngSeconds(self): ...
    Unit: Any = ...

class BoundingBox:
    apicls: Any = ...
    def __init__(self, *args: Any) -> None: ...
    def __getitem__(self, item: Any): ...
    def __melobject__(self): ...
    repr: Any = ...
    def center(self) -> Point: ...
    def clear(self) -> None: ...
    def contains(self, point: Point) -> bool: ...
    def depth(self) -> float: ...
    d: Any = ...
    def expand(self, point: Point) -> None: ...
    def height(self) -> float: ...
    h: Any = ...
    def intersects(self, box: BoundingBox, tol: float=...) -> bool: ...
    def max(self) -> Point: ...
    def min(self) -> Point: ...
    def transformUsing(self, matrix: Matrix) -> None: ...
    def width(self) -> float: ...
    w: Any = ...

def getPlugValue(plug: Any): ...
